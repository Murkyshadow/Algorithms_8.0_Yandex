# У нас дано 1000 машинок, которые едут вперед (или может назад), а еще в право и влево (короче в любую сторону от нанчальной по прямой).
# Надо определить доедет ли машина до финиша или перед этим столкнется с другой машиной или бортом.
# Решается с помощью сортировки событии: для каждой машины вычислим, где и через сколько она столкнется дргуими машинами (или не столкнется) -
# получаем события столкновения 2х машин (сама с собой машина не столкнется) со временем (от начала гонки), но надо аккуратно проверить столкнулись ли эти 2 машины
# (надо аккуратно обработать отрицательные и нулевые скорости, вычислить время пересечения по обоим координатам и сравнить их),
# так же для каждой машины вычисляем время пересечения финиша (при условии, что финиш пересек в пределах ширины поля 0 < finish_y < WEIGHT, иначе машина врезалась в борт и никак не может доехать до финиша)
# Обрабатываем в след. порядке:
# 1) столкновение 2х машин (нам нужны только те которые произошли до финиша включительно y<=L)
# 2) столкновение (пересечение) финиша (должно быть после обработки столкновения 2х машин, тк если столкнуться на финише, то за победу не засчитается),
# будем создавать только если финишировал по игреку в пределах поля, иначе машина в бок уехала
# Сортируем все события по времени и обрабатываем след. образом
# Когда встречаем событие (1) - обрабатываем событие только если обе машины еще в игре, записываем столкнувшиеся машины
# в отдельный сет и делаем это до тех пор пока время или тип события не поменяется
# (тк в одной и той же точке в одно и то же время могут столкнуться больше 2х машин), когда поменялось удаляем из текущих машин (in_game)
# машины, которые столкнулись
# когда встречаем событие (2) - если машина еще в игре, то она победила, записываем такие машины в ответ
# до тех пор пока не изменится тип события или время или не закончатся все события
# Сложность: для каждой машины все машины перебираем, тк 1000 на 1000 = 10**6, потом все эти события надо еще
# отсортировать по времени = n**2*log(n**2) ~ 20 * 10**6 - 20млн операций (в притык должно зайти на питон, но в крайнем случае есть pypy)

def get_time_intersection_coor(coor_car_1, coor_car_2, v_1, v_2):   # получаем время пересечения 2х машин по одной координате
    s_between_cars = coor_car_2 - coor_car_1
    v_convergence = v_1 - v_2   # скорость сближения машин, если сближение будет отрицательным, то расстояние между ними должно быть отрицательным --> время положительное, иначе машины отдаляются друг от друга --> время отрицательное
    if v_convergence == 0 and s_between_cars == 0:    # всегда будут пересекаться (с первой секунды) тк расстояние между ними не изменяется, а текущее равно нулю
        return 0
    elif v_convergence == 0:  # скорость сближения равна нулю, а расстояние между ними != 0 --> никогда не пересекутся
        return -1
    elif s_between_cars == 0 and v_convergence != 0:    # изначально они пересекаются, но после старта разъедутся и больше не пересекутся
        return -1
    return s_between_cars / v_convergence    # время до пересечения по координате (time_to_crash), если время отрицательное, то они отдаляются друг от друга

n, FINISH_x, SIDE_y = map(int, input().split())
cars = [list(map(int, input().split())) for _ in range(n)]  # x, y, v_x, v_y
events = []
CRASH_EVENT, FINISH_EVENT = 1, 2 # типы событий
for ind_car, car in enumerate(cars):
    x, y, v_x, v_y = car    # v_x - скорость вдоль трассы, v_y - скорость поперек трассы
    if v_x > 0: # значит едет в сторону финиша (и доедет, если до этого во что-то не врежется)
        s_to_finish = FINISH_x - x
        time_to_finish = s_to_finish / v_x
        if 0 < time_to_finish*v_y + y < SIDE_y: # иначе врезался в борт --> до финиша не доедет
            events.append((time_to_finish, FINISH_EVENT, ind_car))

    for ind_car_2, car_2 in enumerate(cars[ind_car+1:], ind_car+1):  # проверяем на столкновение с другими машинами
        x2, y2, v_x2, v_y2 = car_2
        time_to_crash_x = get_time_intersection_coor(x, x2, v_x, v_x2)
        time_to_crash_y = get_time_intersection_coor(y, y2, v_y, v_y2)
        if time_to_crash_x < 0 or time_to_crash_y < 0:  # не пересекутся тк не сближаются по иксу или по игрику, остальные машины пересекутся
            continue

        if time_to_crash_y == time_to_crash_x:  # пересеклись и время пересечения по обоим координатам совпало
            time_to_crash = time_to_crash_y
        elif time_to_crash_x == 0:    # всегда пересекаются по иксу --> осталось пересечься по игреку
            time_to_crash = time_to_crash_y
        elif time_to_crash_y == 0:    # всегда пересекаются по игреку --> осталось пересечься по иксу
            time_to_crash = time_to_crash_x
        else:   # пересечения не совпали по времени
            continue
        if 0 < x + time_to_crash*v_x <= FINISH_x and 0 < y + time_to_crash*v_y < SIDE_y:    # нам интересны только столкновения произошедшие до финиша включительно и в пределах поля по игреку (ширине), хотя можно и эти события обработать
            events.append((time_to_crash, CRASH_EVENT, (ind_car, ind_car_2)))

events.sort()
cars_in_game = [True]*n  # машины, которые не выбыли из гонки
cars_in_crashs = set()  # машины попавшие в аварию
time_before_event = 0
winers = []
for ev in events:   # обрабатываем события
    time_event, type_event, ind_car = ev
    if type_event != CRASH_EVENT or time_before_event != time_event: # машины в аварии выбывают
        while cars_in_crashs:
            cars_in_game[cars_in_crashs.pop()] = False
    if type_event == CRASH_EVENT and cars_in_game[ind_car[0]] and cars_in_game[ind_car[1]]: # столкновение двух машин, которые еще не выбыли
        cars_in_crashs.add(ind_car[0])  # не удаляем их из игры тк следующее событие может быть связано с машиной, которая попадет в эту же аварию в это же время
        cars_in_crashs.add(ind_car[1])
    elif type_event == FINISH_EVENT:
        if winers and time_event != time_before_event:  # следующий финишировал в другое время
            break
        if cars_in_game[ind_car]:
            winers.append(ind_car+1)
    time_before_event = time_event

print(len(winers))
print(*sorted(winers))  # если массив пустой, то выведит пустую строку, но тестирующая система это позволяет
