# 22:56 - 00:17
# в dp храним минимальное кол-во переходов после каждого притока,
# как для левого берега так и для правого, и для dp[i][L или R] выбираем
# оптимальный путь, либо с левого берега, либо с правого (+ притоки)
s = input()
ans = s.count('B')  # по ним придется пройти в любом случае, поэтому сразу добавим в ответ и будем их скипать
dp = [[0], [1]]   # расчитываем минимальное кол-во переправ после каждого притока для левого и правого берегов (изначально мы на левом, поэтому = 0, а на правый надо 1 раз перейти реку)
LEFT_COAST, RIGHT_COAST = 0, 1
for direction_inflow in s:
    if direction_inflow == 'L':  # левый приток
        dp[LEFT_COAST].append(min(dp[LEFT_COAST][-1] + 1, dp[RIGHT_COAST][-1] + 1))     # на левом береге можем оказаться с левого берега - перейти поток (+1) или перейти с правого берега (+1)
        dp[RIGHT_COAST].append(min(dp[LEFT_COAST][-2] + 1, dp[RIGHT_COAST][-1]))        # на правом береге можем оказаться с левого берега (+1) или с правого берега (+0)
    elif direction_inflow == 'R':   # правый приток
        dp[LEFT_COAST].append(min(dp[LEFT_COAST][-1], dp[RIGHT_COAST][-1] + 1))         # на левом береге можем оказаться с левого берега (+0) или перейти с правого берега (+1)
        dp[RIGHT_COAST].append(min(dp[LEFT_COAST][-2] + 1, dp[RIGHT_COAST][-1] + 1))    # на правом береге можем оказаться с левого берега (+1) или с правого берега - пройти поток (+1))

print(dp[RIGHT_COAST][-1] + ans)
